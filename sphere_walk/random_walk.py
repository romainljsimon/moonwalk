import numpy as np
from numba import float64
from numba.experimental import jitclass
"""
spec = [
    ('position', float64[:]),
    ('v1', float64[:, :]),   
    ('borns', float64[:]), 
    ('observables', float64[:]),
    ('column_names', uint8) 
]

@jitclass(spec)
"""
class XYZWalk:
    """
    A class that simulates a 3D random walk with optional boundary constraints.
    
    The XYZWalk class models a walker in a 3D space, where each walk step rotates 
    the current position matrix by a small angle theta around a random axis. The 
    walker can be confined by specified bounds, simulating a system with or without walls.
    
    Attributes:
    ----------
    borns : numpy.ndarray
        A 1D array representing the boundary constraints for the walker's x, y, and z positions.
    v1 : numpy.ndarray
        A 3x3 identity matrix that represents the initial position matrix of the walker in 3D space.
    position : numpy.ndarray
        A flattened version of v1, representing the position of the walker in 1D form.
    observables : numpy.ndarray
        An array to store observables related to the walk, initialized with a single zero.
    walls : bool
        A flag to activate boundary constraints. If True, the walker cannot move beyond specified bounds.
    theta : float
        The angle of rotation for each walk step, representing the magnitude of movement per step.
    column_names : list of str
        Names of the position vector components, used for reference and debugging purposes.
        
    Methods:
    -------
    calc_axis() -> numpy.ndarray
        Generates a random unit vector that serves as the rotation axis for the walk step.
        
    walk()
        Executes a single step of the random walk by applying a rotation to v1. If walls are active,
        boundary constraints prevent the position from crossing predefined limits in borns.
    """
    
    def __init__(self, theta: float = 3e-2, walls: bool = False, borns: list = np.array([0.95, 0.95, 0.95])):
        """
        Initializes the XYZWalk instance with specified angle, boundary constraints, and wall behavior.
        
        Parameters:
        ----------
        theta : float, optional
            The angle of rotation for each walk step. Default is 3e-2.
        walls : bool, optional
            If True, boundary constraints are active, limiting the walker within the specified borns.
            Default is False.
        borns : list, optional
            A list or numpy array containing boundary limits for x, y, and z coordinates.
            Default is np.array([0.95, 0.95, 0.95]).
        """
        self.borns = borns
        self.v1 = np.diagflat([1., 1., 1.])      # Initializes as a 3x3 identity matrix.
        self.position = self.v1.flatten()        # Flattens v1 to a 1D position array.
        self.observables = np.array([0])         # Placeholder array for observables.
        self.walls = walls
        self.theta = theta
        self.column_names = ['x1', 'y1', 'z1', 'x2', 'y2', 'z2', 'x3', 'y3', 'z3', 'none']
    
    def calc_axis(self):
        """
        Generates a random unit vector to serve as the rotation axis for each step.
        
        The method samples from a 3D normal distribution and normalizes the result
        to ensure the vector has unit length. This axis is then used to compute 
        the rotation matrix in the walk() method.
        
        Returns:
        -------
        numpy.ndarray
            A unit vector that serves as the axis of rotation.
        """
        vec = np.random.normal(0, 1, 3)  # Sample a random vector from a normal distribution.
        rand_u = vec / np.linalg.norm(vec)  # Normalize to make it a unit vector.
        return rand_u
    
    def walk(self):
        """
        Executes a single random walk step by rotating the walker's position matrix.
        
        Each walk step applies a rotation by `theta` around a random axis generated by 
        `calc_axis()`. The rotation matrix is constructed using the Rodrigues' rotation 
        formula. If `walls` is True, the walker cannot move beyond the boundary values 
        specified in `borns`, and the step is discarded if it violates these constraints.
        """
        # Set up rotation parameters and boundaries
        theta_array = np.array([-self.theta, self.theta])
        bornx, borny, bornz = self.borns
        thetax = np.random.choice(theta_array)
        
        # Calculate the rotation axis
        rand_u = self.calc_axis()
        
        # Construct rotation matrix using Rodrigues' rotation formula
        cross_product = np.cross(rand_u, np.identity(rand_u.shape[0]) * -1)
        tot_rot = (np.cos(thetax) * np.identity(3) + 
                   (1 - np.cos(thetax)) * np.outer(rand_u, rand_u) + 
                   np.sin(thetax) * cross_product)
        
        # Apply rotation to the position matrix v1
        test_rot = tot_rot @ np.ascontiguousarray(self.v1)
        
        # Enforce boundary constraints if walls are active
        if self.walls:
            if test_rot[2, 2] < bornz or test_rot[0, 0] < bornx or test_rot[1, 1] < borny:
                test_rot = self.v1  # Reset to original position if out of bounds
                
        # Update the position matrix and flattened position vector
        self.v1 = test_rot
        self.position = self.v1.flatten()